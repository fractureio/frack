<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>Fake.Git</name></assembly>
<members>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Fake.Git.AssemblyInfo">

</member>
<member name="M:Fake.Git.Branches.pull(System.String,System.String,System.String)">
<summary>
 Pull
</summary>
</member>
<member name="M:Fake.Git.Branches.push(System.String)">
<summary>
 Push all
</summary>
</member>
<member name="M:Fake.Git.Branches.checkout(System.String,System.Boolean,System.String)">
<summary>
 Checks a branch out
</summary>
</member>
<member name="M:Fake.Git.Branches.checkoutTracked``1(System.String,``0,System.String,System.String)">
<summary>
 Checks a branch out
</summary>
</member>
<member name="M:Fake.Git.Branches.deleteTag(System.String,System.String)">
<summary>
 Deletes the given tag
</summary>
</member>
<member name="M:Fake.Git.Branches.tag(System.String,System.String)">
<summary>
 Tags the current branch
</summary>
</member>
<member name="M:Fake.Git.Branches.deleteBranch(System.String,System.Boolean,System.String)">
<summary>
 Deletes the given branch
</summary>
</member>
<member name="M:Fake.Git.Branches.createBranch(System.String,System.String,System.String)">
<summary>
 Creates a new branch from the given commit
</summary>
</member>
<member name="M:Fake.Git.Branches.checkoutBranch(System.String,System.String)">
<summary>
 Performs a checkout of the given branch to the working copy
</summary>
</member>
<member name="M:Fake.Git.Branches.checkoutNewBranch(System.String,System.String,System.String)">
 <summary>Creates a new branch based on the given baseBranch and checks it out to the working copy</summary>
 <param name="repositoryDir">The repository directory.</param>
 <param name="baseBranch">The base branch.</param>
 <param name="branch">The new branch.</param>
</member>
<member name="M:Fake.Git.Branches.revisionsBetween(System.String,System.String,System.String)">
<summary>
 Returns the number of revisions between the two given commits
</summary>
</member>
<member name="M:Fake.Git.Branches.findMergeBase(System.String,System.String,System.String)">
<summary>
 Returns the SHA1 of the merge base of the two given commits
</summary>
</member>
<member name="M:Fake.Git.Branches.getSHA1(System.String,System.String)">
<summary>
 Returns the SHA1 of the given head
</summary>
</member>
<member name="M:Fake.Git.Branches.getAllBranches(System.String)">
<summary>
 Gets all local and remote branches
</summary>
</member>
<member name="M:Fake.Git.Branches.getRemoteBranches(System.String)">
<summary>
 Gets all remote branches
</summary>
</member>
<member name="M:Fake.Git.Branches.getLocalBranches(System.String)">
<summary>
 Gets all local branches
</summary>
</member>
<member name="">

</member>
<member name="T:Fake.Git.Branches">

</member>
<member name="M:Fake.Git.CommandHelper.findGitDir(System.String)">
<summary>
 Searches the git dir recursivly up to the root
</summary>
</member>
<member name="">

</member>
<member name="M:Fake.Git.CommandHelper.runSimpleGitCommand(System.String,System.String)">
<summary>
 Runs the git command and returns the first line of the result
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fake.Git.CommandHelper.directExec(Microsoft.FSharp.Core.FSharpFunc`2{System.Diagnostics.ProcessStartInfo,Microsoft.FSharp.Core.Unit})">
<summary>
 Runs the given process and returns the exit code
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Fake.Git.CommandHelper">

</member>
<member name="M:Fake.Git.CommitMessage.setMessage(System.String,System.String)">
<summary>
 Sets the commit message
</summary>
</member>
<member name="M:Fake.Git.CommitMessage.getCommitMessage(System.String)">
<summary>
 Gets the commit message
</summary>
</member>
<member name="">

</member>
<member name="T:Fake.Git.CommitMessage">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fake.Git.FileStatus.cleanWorkingCopy(System.String)">
<summary>
 Cleans the working copy by doing a git reset --hard and a clean -f
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fake.Git.FileStatus.isInTheMiddleOfConflictedMerge(System.String)">
<summary>
 Returns true if the working copy is in a conflicted merge otherwise false
</summary>
</member>
<member name="M:Fake.Git.FileStatus.getConflictedFiles(System.String)">
<summary>
 Gets all conflicted files
</summary>
</member>
<member name="M:Fake.Git.FileStatus.getChangedFilesInWorkingCopy(System.String,System.String)">
<summary>
 Gets the changed files since the given revision incl. changes in the working copy
</summary>
</member>
<member name="M:Fake.Git.FileStatus.getAllFiles(System.String)">
<summary>
 Gets all changed files in the current revision
</summary>
</member>
<member name="M:Fake.Git.FileStatus.getChangedFiles(System.String,System.String,System.String)">
<summary>
 Gets the changed files between the given revisions
</summary>
</member>
<member name="T:Fake.Git.FileStatus">

</member>
<member name="M:Fake.Git.Information.isAheadOf(System.String,System.String,System.String)">
<summary>
 Returns true if rev1 is ahead of rev2
</summary>
</member>
<member name="M:Fake.Git.Information.showName(System.String,System.String)">
<summary>
 Returns a friendly name from a SHA1
</summary>
</member>
<member name="M:Fake.Git.Information.isCleanWorkingCopy(System.String)">
<summary>
 Checks if the working copy is clean
</summary>
</member>
<member name="M:Fake.Git.Information.showStatus(System.String)">
<summary>
 Shows the git status
</summary>
</member>
<member name="M:Fake.Git.Information.getCurrentSHA1(System.String)">
<summary>
 Returns the SHA1 of the current HEAD
</summary>
</member>
<member name="M:Fake.Git.Information.getVersion(System.String)">
<summary>
 Gets the git version
</summary>
</member>
<member name="M:Fake.Git.Information.getBranchName(System.String)">
<summary>
 Gets the git branch name
</summary>
</member>
<member name="T:Fake.Git.Information">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fake.Git.Merge.merge(System.String,System.String,System.String)">
<summary>
 Performs a merge of the given branch with the current branch
</summary>
</member>
<member name="M:Fake.Git.Merge.compareBranches(System.String,System.String,System.String)">
 <summary>
 Tests whether branches and their "origin" counterparts have diverged and need
 merging first.
 </summary>

 <param name="repositoryDir">The path to the repository.</param>
 <param name="local">The local branch name.</param>
 <param name="remote">The remote branch name.</param>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fake.Git.Merge.getMergeMessage(System.String)">
<summary>
 Gets the current merge message
</summary>
</member>
<member name="T:Fake.Git.Merge">

</member>
<member name="M:Fake.Git.Rebase.rebaseOrFallbackOnMerge(System.String,System.String)">
 <summary>
 Tries to rebase on top of the given branch.
 If the rebasing process fails a normal merge will be started.
 </summary>
 <returns>If the process used merge instead of rebase.</returns>
</member>
<member name="M:Fake.Git.Rebase.skip(System.String)">
<summary>
 Restart the rebasing process by skipping the current patch. 
</summary>
</member>
<member name="M:Fake.Git.Rebase.continueRebase(System.String)">
<summary>
 Restart the rebasing process after having resolved a merge conflict. 
</summary>
</member>
<member name="M:Fake.Git.Rebase.abort(System.String)">
<summary>
 Restore the original branch and abort the rebase operation. 
</summary>
</member>
<member name="M:Fake.Git.Rebase.start(System.String,System.String)">
<summary>
 Performs a rebase on top of the given branch with the current branch
</summary>
</member>
<member name="T:Fake.Git.Rebase">

</member>
<member name="M:Fake.Git.Repository.init(System.String,System.Boolean,System.Boolean)">
<summary>
 Inits a git repository
</summary>
</member>
<member name="M:Fake.Git.Repository.clone(System.String,System.String,System.String)">
<summary>
 Clones a git repository
</summary>
</member>
<member name="T:Fake.Git.Repository">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Fake.Git.Reset">

</member>
<member name="M:Fake.Git.SHA1.showObjectHash(System.String,System.String)">
<summary>
 shows the SHA1 calculated by git
</summary>
</member>
<member name="M:Fake.Git.SHA1.calcGitSHA1(System.String)">
<summary>
 Calculates the SHA1 like git
</summary>
</member>
<member name="M:Fake.Git.SHA1.calcSHA1(System.String)">
<summary>
 Calculates the SHA1 for a given string
</summary>
</member>
<member name="T:Fake.Git.SHA1">

</member>
<member name="M:Fake.Git.SanityChecks.checkIsRemoteBranch(System.String,System.String)">
<summary>
 Checks if the given branch is a remote branch.
</summary>
</member>
<member name="M:Fake.Git.SanityChecks.checkIsLocalBranch(System.String,System.String)">
<summary>
 Checks if the given branch is a local branch.
</summary>
</member>
<member name="M:Fake.Git.SanityChecks.checkIfBranchIsAbsent(System.String,System.String)">
<summary>
 Checks if the given branch is absent.
</summary>
</member>
<member name="M:Fake.Git.SanityChecks.checkIfBranchExists(System.String,System.String)">
<summary>
 Checks if the given branch exists.
</summary>
</member>
<member name="">

</member>
<member name="T:Fake.Git.SanityChecks">

</member>
<member name="M:Fake.Git.Staging.StageFile(System.String,System.String)">
<summary>
 Adds a file to the staging area
</summary>
</member>
<member name="T:Fake.Git.Staging">

</member>
<member name="M:Fake.Git.Stash.pop(System.String)">
<summary>
 Remove a single stashed state from the stash list and 
 apply it on top of the current working tree state, 
 i.e., do the inverse operation of git stash save. 
 The working directory must match the index. 
</summary>
</member>
<member name="M:Fake.Git.Stash.push(System.String,System.String)">
<summary>
 Stash the changes in a dirty working directory away.
</summary>
</member>
<member name="T:Fake.Git.Stash">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fake.Git.Submodule.add(System.String,System.String,System.String,System.String)">
 <summary>Adds a submodule to the current repository.</summary>
 <param name="superRepositoryDir">The super repository.</param>
 <param name="remotePath">The path to the remote repository of the submodule.</param>
 <param name="localPath">The local path to the submodule.</param>
 <param name="branch">The branch to  clone. (can be null)</param>
</member>
<member name="M:Fake.Git.Submodule.init(System.String,System.String)">
<summary>
 Inits a submodule
</summary>
</member>
<member name="M:Fake.Git.Submodule.getSubModules(System.String)">
<summary>
 Gets all submodules
</summary>
</member>
<member name="">

</member>
<member name="T:Fake.Git.Submodule">

</member>
</members>
</doc>
